<?php

if ( !defined( 'MEDIAWIKI' ) ) {
	echo( "This file is an extension to the MediaWiki software and cannot be used standalone.\n" );
	die( 1 );
}

/**
 * @brief Class DpleFeatureExtrax.
 *
 * @file
 *
 * @ingroup Extensions
 * @ingroup Extensions-DynamicPageListEngine
 *
 * @author [RV1971](http://www.mediawiki.org/wiki/User:RV1971)
 *
 */

/**
 * @brief Selection by extrax information.
 *
 * Recognizes the parameters `extrax` and `notextrax`. `extrax` selects
 * exact matches of the extrax information appended to the sort key
 * (see documentation of
 * DpleFeatureResults::toTitles()) for the first
 * selected category. `notextrax` select the complement of this. If no
 * categories are selected, the parameters are silently ignored.
 *
 * If `extrax` is an array, the result is
 * (obviously) the union of the record sets satisfying its elements,
 * unlike other parameters (including `notextrax`) where the
 * result is the intersection.
 *
 * @ingroup Extensions
 * @ingroup Extensions-DynamicPageListEngine
 */
class DpleFeatureExtrax extends DpleFeatureBase
implements DpleFeatureInterface {
	/* == private variables == */

	/** @brief Extrax information pages to select should provide with
	 * the category tag for the first category. */
	private $extraxs_;

	/** @brief Extrax information pages to select should not provide
	 * with the category tag for the first category. */
	private $notExtraxs_;

	/* == magic methods == */

	/// Constructor. Evaluate parameters.
	public function __construct( array $params, array &$features ) {
		parent::__construct( $features );

		if ( isset( $params['extrax'] ) ) {
			$this->extraxs_ = array_map( array( $this, 'parseText' ),
				(array)$params['extrax'] );
		}

		if ( isset( $params['notextrax'] ) ) {
			$this->notExtraxs_ = array_map( array( $this, 'parseText' ),
				(array)$params['notextrax'] );
		}
	}

	/* == accessors == */

	/// Get @ref $extraxs_.
	public function getExtraxs() {
		return $this->extraxs_;
	}

	/// Get @ref $notExtraxs_.
	public function getNotExtraxs() {
		return $this->notExtraxs_;
	}

	/// Get the database cost generated by this feature instance.
	public function getCost() {
		/** If @ref $extraxs_ is an array, its items are put together
		 *	with OR operators, which is typcially slow, therefore one
		 *	unit of @ref DpleFeature::getCost() is
		 *	accounted for each item. Items in @ref $notExtraxs_ instead
		 *	are put together with AND, which is typically efficient,
		 *	and therefore only one unit is accounted for the whole
		 *	array, if any. */
		return (count( $this->extraxs_ ) + (int)(bool)$this->notExtraxs_)
			* parent::getCost();
	}

	/* == operations == */

	/// Modify a given query. @copydetails DpleFeatureBase::modifyQuery()
	public function modifyQuery( DpleQuery &$query ) {
		$containsFeature = $this->getFeature( 'DpleFeatureContains' );

		/** Do nothing if no contains was defined. */
		if ( !isset( $containsFeature )
			|| !$containsFeature->getLinkedCount() ) {
			return;
		}

		$dbr = $query->getDbr();

		/** Otherwise, also fetch the sort key for the first
		 *	category. */
		$query->addVars( array( 'sortkeyx' => 'clx1.cl_sortkey_prefix' ) );

		if ( $this->extraxs_ ) {
			$extraxConds = array();
			
			/** Add conditions based on @ref $extraxs_. */
			foreach ( $this->extraxs_ as $extrax ) {
				$extraxConds[] = 'clx1.cl_sortkey_prefix'
					. $dbr->buildLike( $dbr->anyString(), "|$extrax" );
			}
			
			$query->addConds( '(' . implode( ' OR ', $extraxConds ) . ')' );
		}
		
		/** Add conditions based on @ref $notExtraxs_. */
		foreach ( (array)$this->notExtraxs_ as $extrax ) {
			$query->addConds( 'clx1.cl_sortkey_prefix NOT '
				. $dbr->buildLike( $dbr->anyString(), "|$extrax" ) );
		}
	}
}
