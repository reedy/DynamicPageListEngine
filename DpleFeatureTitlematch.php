<?php

if ( !defined( 'MEDIAWIKI' ) ) {
	echo( "This file is an extension to the MediaWiki software and cannot be used standalone.\n" );
	die( 1 );
}

/**
 * @brief Class DpleFeatureTitlematch.
 *
 * @file
 *
 * @ingroup Extensions
 * @ingroup Extensions-DynamicPageListEngine
 *
 * @author [RV1971](http://www.mediawiki.org/wiki/User:RV1971)
 *
 */

/**
 * @brief Selection by title prefix, suffix or fragment.
 *
 * Recognizes the parameters `titleprefix, nottitleprefix,
 * titlesuffix, nottitlesuffix, titlecontains` and `nottitlecontains`,
 * each of which may be a title substring or an array thereof. As
 * usual, spaces and underscores in titles are equivalent.
 *
 * If `titleprefix, titlesuffix, titlecontains` is an array, the
 * result is (obviously) the union of the record sets satisfying its
 * elements, unlike other parameters (including `nottitleprefix`)
 * where the result is the intersection.
 *
 * This class implements a `[not]title{prefix suffix contains}`
 * condition but not a general `[not]titlematch` because escaping of
 * the % and _ characters depends on the database backend, hence
 * arbitrary LIKE patterns would raise portability isssues.
 *
 * @ingroup Extensions
 * @ingroup Extensions-DynamicPageListEngine
 */
class DpleFeatureTitlematch extends DpleFeatureBase
implements DpleFeatureInterface {
	/* == private variables == */

	/// Array of title prefixes pages to select should have.
	private $titleprefixes_;

	/// Array of title prefixes pages to select should not have.
	private $notTitleprefixes_;

	/// Array of title suffixes pages to select should have.
	private $titlesuffixes_;

	/// Array of title suffixes pages to select should not have.
	private $notTitlesuffixes_;

	/// Array of strings that titles of pages to select should contain.
	private $titlecontains_;

	/// Array of strings that titles of pages to select should not contain.
	private $notTitlecontains_;

	/* == magic methods == */

	/// Constructor. Evaluate parameters.
	public function __construct( array $params, array &$features ) {
		parent::__construct( $features );

		foreach ( array(
				'titleprefix' => 'titleprefixes_',
				'nottitleprefix' => 'notTitleprefixes_',
				'titlesuffix' => 'titlesuffixes_',
				'nottitlesuffix' => 'notTitlesuffixes_',
				'titlecontains' => 'titlecontains_',
				'nottitlecontains' => 'notTitlecontains_'
			) as $key => $member ) {

			if ( isset( $params[$key] ) ) {
				$this->$member =
					array_map( array( $this, 'parseTitleSubstring' ),
						(array)$params[$key] );
			}
		}
	}

	/* == accessors == */

	/// Get @ref $titleprefixes_.
	public function getTitleprefixes() {
		return $this->titleprefixes_;
	}

	/// Get @ref $notTitleprefixes_.
	public function getNotTitleprefixes() {
		return $this->notTitleprefixes_;
	}

	/// Get @ref $titlesuffixes_.
	public function getTitlesuffixes() {
		return $this->titlesuffixes_;
	}

	/// Get @ref $notTitlesuffixes_.
	public function getNotTitlesuffixes() {
		return $this->notTitlesuffixes_;
	}

	/// Get @ref $titlecontains_.
	public function getTitlecontains() {
		return $this->titlecontains_;
	}

	/// Get @ref $notTitlecontains_.
	public function getNotTitlecontains() {
		return $this->notTitlecontains_;
	}

	/// Get the database cost generated by this feature instance.
	public function getCost() {
		/** If @ref $titleprefixes_, @ref $titlesuffixes_, @ref
		 *	$titlecontains_ are arrays, the items in each array are
		 *	put together with OR operators, which is typcially slow,
		 *	therefore one unit of @ref
		 *	DpleFeature::getCost() is accounted for
		 *	each item. Items in @ref $notTitleprefixes_ etc. instead
		 *	are put together with AND, which is typically efficient,
		 *	and therefore only one unit is accounted for each
		 *	array. */
		return (count( $this->titleprefixes_ )
			+ count( $this->titlesuffixes_ )
			+ count( $this->titlecontains_ )
			+ (int)(bool)$this->notTitleprefixes_
			+ (int)(bool)$this->notTitlesuffixes_
			+ (int)(bool)$this->notTitlecontains_) * parent::getCost();
	}

	/* == operations == */

	/// Modify a given query. @copydetails DpleFeatureBase::modifyQuery()
	public function modifyQuery( DpleQuery &$query ) {
		$dbr = $query->getDbr();

		if ( $this->titleprefixes_ ) {
			$prefixConds = array();

			foreach ( $this->titleprefixes_ as $prefix ) {
				$prefixConds[] = 'page_title'
					. $dbr->buildLike( $prefix, $dbr->anyString() );
			}

			$query->addConds( '(' . implode( ' OR ', $prefixConds ) . ')' );
		}

		foreach ( (array)$this->notTitleprefixes_ as $prefix ) {
			$query->addConds( 'page_title NOT'
				. $dbr->buildLike( $prefix, $dbr->anyString() ) );
		}

		if ( $this->titlesuffixes_ ) {
			$suffixConds = array();

			foreach ( $this->titlesuffixes_ as $suffix ) {
				$suffixConds[] = 'page_title'
					. $dbr->buildLike( $dbr->anyString(), $suffix );
			}

			$query->addConds( '(' . implode( ' OR ', $suffixConds ) . ')' );
		}

		foreach ( (array)$this->notTitlesuffixes_ as $suffix ) {
			$query->addConds( 'page_title NOT'
				. $dbr->buildLike( $dbr->anyString(), $suffix ) );
		}

		if ( $this->titlecontains_ ) {
			$containsConds = array();

			foreach ( $this->titlecontains_ as $contains ) {
				$containsConds[] = 'page_title'
					. $dbr->buildLike( $dbr->anyString(), $contains,
						$dbr->anyString() );
			}

			$query->addConds( '(' . implode( ' OR ', $containsConds ) . ')' );
		}

		foreach ( (array)$this->notTitlecontains_ as $contains ) {
			$query->addConds( 'page_title NOT'
				. $dbr->buildLike( $dbr->anyString(), $contains,
					$dbr->anyString() ) );
		}
	}
}

